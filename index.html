<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kubernetes Applications Management Conventions | rwxrob.github.io/k8sapp</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Kubernetes Applications Management Conventions | rwxrob.github.io/k8sapp</h1>
</header>
<p>There are many ways to install and manage Kubernetes applications:</p>
<ul>
<li><code>kubectl</code> Scripts</li>
<li>Kustomize</li>
<li>Helm</li>
<li>Modified Helm</li>
<li>Operator Framework</li>
<li>Custom Operators</li>
<li>Adapted Terraform and/or Ansible</li>
</ul>
<p>Cloud native administrators are forced to learn one or all of these since there is no agreement in the industry as to any standard. Moreover, the industry is full of overly-hyped frameworks and ‚Äúpackage managers‚Äù vying for dominance while failing to meet even minimal requirements for air-gapped security and sustainability. This situation, brought about by attempting to force imperative IT business processes into declarative ‚Äúsolutions,‚Äù has created chaos and a climate of conflict and shame for those refusing to use the Kubernetes application management ‚Äústandards‚Äù when, in fact, the safest and most sustainable approach is to keep things simple: just use Kubernetes resource files and <code>kubectl</code>.</p>
<p>Amidst the chaos, a common set of admin practices seems mandatory so that each application is looked after in a way that is implementation agnostic (like you would do with any programming interface). One does not care <em>how</em> these practices are fulfilled, only that they are. Some can be scripted, some are a matter of documentation, but all are required for any application to makes it into your production cluster. One could say that every application can implement its own <em>methods</em> for the same <em>operations</em>. Operations are the actions taken by any cloud native admin, or by a script on behalf of the admin.</p>
<p>To be clear, this is not yet-another-tool. It‚Äôs just a matter of agreeing on what everyone on the admin team should do with respect to <em>all</em> Kubernetes applications while allowing each its own specificity.</p>
<p>The K8SAPP contract simply asks that all team members agree to the following:</p>
<ul>
<li>Maintain manifest of all installed applications in own repo (ex: <code>k8sapps</code>)</li>
<li>Provide a Git repo for each application (allows GitOps, etc.)</li>
<li>Tag each version using semver versioning (ex: <code>v0.1.1</code>)</li>
<li>Use a consistent prefix (ex: <code>k8sapp-</code>)</li>
<li>Provide a detailed README.md with description, etc.</li>
<li>Provide a metadata file (ex: <code>k8sapp.yaml</code>)</li>
<li>Keep a vendored copy of the original application (ex: <code>helm/some-chart-0.8.tgz</code>, <code>helm/index.yaml</code>)</li>
<li>Document the following procedures (as <code>##</code> in README.md):
<ul>
<li>Fetch - acquire from external authoritative source</li>
<li>Understand - flatten, read README, Helm charts, policies, deps, etc.</li>
<li>Configure - adapt original to match environment (<code>values.yaml</code>)</li>
<li>Install - install the application for the first time</li>
<li>Upgrade - install an upgraded version of the application</li>
<li>Uninstall - remove all traces of the application from the cluster</li>
<li>Check - latest version, dependencies, is there an update?</li>
</ul></li>
<li>Add a <em>## Related</em> section with related reading</li>
<li>Keep a manifest of all installed apps in own Git repo (ex: <code>k8sapps</code>)</li>
</ul>
<blockquote>
<p>üí° Consider creating a <code>template-k8sapp</code> for your organization in your Enterprise GitHub so that people can simply clone/copy it and fill it in.</p>
</blockquote>
<h2 id="k8sapp-embraces-git-instead-of-shunning-it">K8SAPP Embraces Git Instead of Shunning It</h2>
<p>One of the most annoying design decisions of Helm is discarding the world‚Äôs best source management utility (Git) and replacing it with tarballs. This is a source of much confusion and extra work when people realize they still need a way to track all their customizations and forks to inadequate templates. Had the Helm project had the foresight to keep all ‚ÄúCharts‚Äù as repos this would all go away. We could just fork a ‚Äúchart‚Äù and make our changes and ensure upstream changes are made over time. This is a tried and true Git process used by most applications development for over a decade. For some foolish reason, the Helm project choose to discard this wisdom.</p>
<p>A K8SAPP undoes what Helm has broken by flattening Helm charts into their default Kubernetes resource YAML files and putting them into Git repos for proper management.</p>
<h2 id="k8sapp-conventional-metadata">K8SAPP Conventional Metadata</h2>
<p>Having consistent metadata in each K8SAPP Git repo allows the consolidation of this data later into a master manifest used to regularly check for version updates and such. Each Git repo should begin with a specific prefix following the K8SAPP convention (preferably <code>k8sapp-</code>). Each K8SAPP repo should contain a <code>k8sapp.yaml</code> containing the following metadata:</p>
<p><code>fullname</code> unique long name within the scope of a given Git repo collection or service that may contain qualifiers similar to container image references (ex: <code>rwxrob/jupyterhub</code>)</p>
<p><code>shortname</code> for referencing easily within local contexts and corresponding to the git repo name after the prefix (<code>k8sapp-jhub</code> -&gt; <code>jhub</code>)</p>
<p><code>title</code> descriptive title of 70 Unicode characters or less for creating lists of K8SAPPs</p>
<p><code>version</code> semver of this K8SAPP, <em>not</em> it‚Äôs origin, <code>git tag</code> also must be synced</p>
<p><code>repo</code> Git-friendly reference to the required source Git repo (usually HTTP)</p>
<p><code>maintainers</code> list of primary contacts with <code>name</code>, <code>email</code>, <code>url</code>, <code>slack</code></p>
<p><code>includes</code> list of sources composed into K8SAPP (Helm charts, other repos, etc.)</p>
<p><code>includes.name</code> unique name within this K8SAPP repo</p>
<p><code>includes.title</code> descriptive title, 70 Unicode characters or less</p>
<p><code>includes.type</code> one of <code>helm</code>, <code>git</code>, etc.</p>
<p><code>includes.url</code> primary source of information about</p>
<p><code>includes.version</code> semantic version as indicated by source</p>
<p><code>includes.sources</code> one or more sources that contain the composed include</p>
<p><em>Why no summary or description?</em></p>
<p>These should best be placed in the required README.md file within the required Git repo since CommonMark is much more expressive.</p>
<p><em>Why no <code>kubeVersion</code>?</em></p>
<p>The <code>kubeVersion</code> in Helm is disastrously broken to the point of being dangerous. In addition, any indication of a K8SAPP being usable by a specific version <em>or greater</em> is simply a lie since there is no way to guarantee future compatibility.</p>
<p>Moreover, the Kubernetes version is but one consideration. Some K8SAPPs may have dependencies on specific versions of other installed applications.</p>
<p>This complexity is best communicated and managed in the README.md file itself and should probably not be automated.</p>
<h2 id="vendoring-when-necessary">Vendoring (When Necessary)</h2>
<p>Vendoring is the process of saving external dependencies with one‚Äôs own code. The K8SAPP conventions leverage the vendoring approach to preserve Helm charts and other YAML resource files that originate outside of the project. Acquiring these external resources can be included in a <code>fetch</code> action or simply documented in the README.md when an Internet connection cannot be assumed.</p>
<h2 id="package-management-will-never-work-in-kubernetes">‚ÄúPackage Management‚Äù Will Never Work in Kubernetes</h2>
<blockquote>
<p>Kubernetes is not a Linux distro!</p>
</blockquote>
<p>The term ‚Äúpackage management‚Äù (popularized wrongly by the Helm project) does not relate to Kubernetes and should be avoided. It is causing immense confusion and chaos in the industry. Use any of the following terms instead:</p>
<ul>
<li>application build utility</li>
<li>configuration management assistant</li>
</ul>
<p>Helm is closer to Webpack (a NodeJS build tool) than to APT (the Ubuntu package manager). Calling Helm a ‚Äúpackage manager‚Äù is simply a lie. Let‚Äôs look at an actual package manager in comparison.</p>
<p>When installing <code>openssh-server</code> one need only execute <code>apt install openssh-server</code> and everything works because APT has been designed to work with Debian/Ubuntu systems and all of those systems ‚Äî with regard to software installation and management ‚Äî follow the same standard. There is no intermediate validation step, no need to comb through the source code to make sure it works on your computer, no need to add extra dependencies that are not covered by the APT system itself, no need to change references from external image dependencies into internal ones, no need to copy down the package specification file to ensure we have a copy of it. Everything just works. <em>That</em> is what a package manager provides.</p>
<p>Package managers work because the distros that support them have a contract to provide what those package managers needs. There is a concrete agreement between the creators of the distro and the creators of the package manager. Such a relationship <em>does not exist</em> between any would-be Kubernetes ‚Äúpackage manager‚Äù nor could there ever be because every single Kubernetes cluster is completely different.</p>
<p>Consider the process of installing and maintaining a Helm chart. First you identify the chart, then copy down the tarball, uncompress it, look through the defaults with <code>helm template ...</code> read through the templates themselves looking for bugs and places to customize, check the Git repo to see if any of the open issues relates to you, change the references to external images to internal mirrored copies of the images, run the resource files through OPA <code>conftest</code> to pro-actively ensure they meet security policies, then attempt to install only to discover that you must create additional RBAC resources before it will even run, and then be able to undo all of that customization once you remove or upgrade your ‚Äúpackage‚Äù. This is <em>not</em> package management. This is software configuration, building, and installation. Helm is <em>not</em> a package manager. It never was. It was born out of the needs for application creators to make it easier to <em>build</em> applications, not install and manage them.</p>
<p>Helm had good intentions, but Helm tried to provide an impossible solution. As much as naive tech-blog writers would have you think otherwise, Kubernetes is not anything like a Linux distribution. Every Kubernetes cluster is unique and has its own configurations and requirements that require a large amount of customization, even between development and production clusters. This fact makes creating a standard ‚Äúpackage manager‚Äù impossible. It would be like creating an APT system that addressed every single different Linux distro available today. The fallacy that such applications can be managed in the same simple way is the source of much wasted time, money, and safety.</p>
<p>One popular attempt at a universal solution to applications management and installation demonstrates how ludicrous this all is. The Operator Framework (originally from RedHat) is a disastrous security failure requiring its OLM to have full cluster admin permissions and placing the responsibility for cluster security on the administrators who are warned (despite the open tickets regard this massive security flaw) to ‚Äúcheck anything you install with it to be sure it‚Äôs safe.‚Äù Imagine telling that to APT users. ‚ÄúBefore you do that <code>apt install</code> first make sure the package is safe.‚Äù Keep in mind that Helm 2 with Tiller was shamed out of existence by the industry for attempting the same thing.</p>
<p>Ironically, even though OLM has the equivalent of (what I call) enterprise root (root not just to one server, but your whole enterprise cluster) it is still unable to provide the simplicity of a ‚Äúpackage manager‚Äù we‚Äôve come to expect when the distro is relatively locked down. Again, the problem is with the design assumption, not the technology. Kubernetes is not Linux distro. It‚Äôs anything but. Please stop perpetuating this dangerous comparison.</p>
<p>Instead, we should be focused on facilitating duplication of application code and adding sustainable practices for maintaining that code over time leveraging the same successful process evolved from software applications development. Many do not like to hear this, but you cannot administer a Kubernetes cluster without software development skills, notably GitOps, CI/CD, shell scripting, Go code review, and YAML/JSON configuration. Make sure your administrators are keeping these skills up to date.</p>
<h2 id="helm-deployment-from-hell-a-reality-check">Helm Deployment from Hell, A Reality Check</h2>
<p>By now you‚Äôve probably heard of Helm and used it to deploy software into your Kubernetes cluster. In fact, in 2022 it is now required learning for the certification exam. But let‚Äôs be honest, Helm is horrible. You‚Äôve likely learned this yourself. Helm is not what you were sold when you first heard about it.</p>
<p><strong>Helm is not a ‚Äúpackage manager‚Äù</strong> like <code>apt</code> or <code>yum</code> or whatever. In fact, the only thing Helm has in common with a <em>true</em> package manager is the aggregation of lots of stuff that eventually needs to be installed and a few common top-level usage verbs: <code>deploy</code>, <code>uninstall</code>, etc.</p>
<p><strong>Helm charts are not packages.</strong> Charts are just a bunch of YAML and Go templates organized in no particular way. There‚Äôs no standard, no convention, nothing. Every single chart does things slightly differently, which would be fine except ‚Ä¶</p>
<p><strong>Helm requires you to read chart files to be sure you get what you want.</strong> You simply cannot trust a Helm chart all by itself. If you haven‚Äôt learned this lesson by now, you definitely will. It is a fundamental best practice to read just about every line of the Helm templates and values to actually understand what the chart is going to do (or not do) to your cluster. Not doing so is simply dangerous.</p>
<p><strong>Helm charts are <em>not</em> easy to create and frequently contain problems.</strong> Kubernetes is crazy complicated meaning that those creating Helm charts inevitably make mistakes simply from the nature of the task complexity. At a minimum, you must add OPA Gatekeeper policy constraints that apply to your cluster and are therefore almost never hard-coded into any chart meaning you either use their escape hatches to add them or fork the main template and add them directly since they were omitted, or monkey patch your additions after Helm does its install from a bash script. This insanity is decidedly different than any ‚Äúpackage manager‚Äù where you can safely trust it to do the right things (but not always). Bottom line: you better at least read your chart code before installing it and you‚Äôll probably have to write more code to do what you want.</p>
<p><strong>Helm obfuscates an already complicated Kubernetes resource YAML syntax.</strong> Just when you got good at ‚ÄúYAML Kubernetes programming‚Äù you realized that Helm chart creators have taken liberties with even the most consistent stuff, like a Deployment‚Äôs <code>.spec.containers[].resources.limits.cpu</code> and have buried it under the whimsical monikers decided by the persons who created the Helm chart. This is infuriating. Those who created the Helm chart either force you to alter the chart source code itself (removing the entire value proposition of putting it into a chart in the first place) or they add something like <code>extraConfigs</code> that you would never guess without having read a dozen other charts that follow the same non-convention.</p>
<p>‚ÄúSo what is a cloud-native engineer to do?‚Äù</p>
<p><strong>Avoid Helm whenever possible.</strong> This might seem like an unpopular opinion at first, after all, why is Helm including in the CNCF certification if it is <em>not</em> a standard? But the reality is that most senior cloud native community members including Kubernetes book authors, CNCF board members, and senior architects at major Fortune 500 companies advice to avoid Helm wherever possible, even that flattening a Helm chart is preferred in almost every case.</p>
<p>Why?</p>
<p>Because there is substantial, objective evidence that creating deployments that depend on Helm is a disaster waiting to happen. Most will only do it when forced to do it. It is far simpler to simply write a Go binary to handle all your installs and uninstalls following a common, intuitive convention when needed, or just a simple shell script combined with YAML files. You can still use Go templates and YAML files to allow people to pass in their configurations and customizations, but make your main deployment mechanism a single Go binary that can be easily versioned and managed as the <em>software</em> that is it.</p>
<p><strong>The Helm disaster is not entirely Helm‚Äôs fault.</strong> The entire ‚Äúdeclarative‚Äù model of Kubernetes is fundamentally broken on several levels with regard to applications installation and management. Things that should have been written as imperative procedures are written in complicated, configuration templates with obscure logic instead of YAML declarations since YAML does not allow imperative logic, which is why ‚Ä¶</p>
<p><strong>It is Kubernetes‚Äô fault Helm is so bad.</strong> The overengineered complexity and insistence that <em>everything</em> be ‚Äúdeclarative‚Äù in Kubernetes has forced imperative logic into things like Helm (Go) templates leaving Helm in the very difficult middle-space between declarative and imperative. This is why Helm is so ugly. It is a ton of declarative YAML and imperative templates mixed into an incomprehensible mess.</p>
<p><strong>Helm (Go) templates are where the imperative stuff ends up.</strong> Unfortunately, the most powerful part of Go templates is entirely omitted: creating your own operators with niladic functions, something that you <em>could</em> do if you didn‚Äôt use Helm and just wrote your installer in Go directly (which is the direction NAML seems to be headed). Imagine if Helm tried to allow template expansion. We would have chart creators building wildly complicated Go templates, they would even create their own binary extensions in Go. Writing application installers in Go is always more powerful and simpler in such cases.</p>
<p><strong>Why not just write the whole thing as code ‚Äî in one language ‚Äî in the first place?</strong> If you are honest, you will admit that you have at least one script or system that ‚Äúwraps‚Äù Helm to get it to do what you need. Why not just drop Helm entirely and write your own installers for your applications in Go or Bash. Go is drop-dead simple to learn and already has Go templates (if and when you need them). By packaging your application as a single Go executable you drop tons of unnecessary abstraction layers and obfuscation that are not only less sustainable and annoying, but also inherently less secure. The Go Kubernetes API and package are amazingly simple compared to the spaghetti code created with Helm (or even YAML resource files themselves).</p>
<p><strong>‚ÄúWhat about consistency?‚Äù</strong> The Helm scenario from Hell I‚Äôve described is anything but consistent. You already have best possible consistency with the Kubernetes API itself and Go package itself. The reason it is no more work to get your users to understand your single command than it is to use Helm is because of all the reality that Helm forces on you. You <em>are</em> coding when you install a Helm chart. This is not some <code>apt install yourapp</code>. You have coded YAML files, and sometimes template extensions forcing you to ‚Äúfork‚Äù the original chart. You‚Äôve added scripts for things that cannot be done in either YAML or templates.</p>
<p><strong>Helm claims to simplify installation but doesn‚Äôt.</strong> For all the reasons mentioned you end up with a complicated, per-chart spaghetti monster that you have to kill, pick apart, extend, and paste back together with home-grown bash scripts to get a consistent deployment working at all. Why not just use <em>actual</em> resource files and Go templates as a best-practice and drop Helm entirely? Just code it in Bash or Go</p>
<h2 id="operator-framework-operator-lifecycle-manager-olm-is-dangerous">Operator Framework / Operator Lifecycle Manager (OLM) is Dangerous</h2>
<p>The Operator Framework is a disastrous, irreparable failure. OLM with full cluster-admin privileges is just Helm 2 Tiller all over again, but worse. Not only does OLM require enterprise root (my term for cluster-admin to your entire cluster) but it also <em>requires</em> access to the Internet to pull operators from their hub to then be run as root. You can forget about being ‚Äúair gapped‚Äù at all. You would think all the stuff RedHat spews about Docker and running as root that someone would have said something before this monstrosity was ever released. No one should <em>ever</em> consider using the Operator Framework, period. In fact, my confidence in RedHat in the cloud-native space is now at an all-time low after discovering this. This is just idiotic architecture. They‚Äôve had a ticket open for more than a year pointing out this massive security risk and the responses are downright juvenile:</p>
<blockquote>
<p>‚ö†Ô∏è The OLM approach to K8S software installation and management does not provide for organizations with ‚Äúair gapped‚Äù policies and architecture. It simply does not work without Internet access to <code>operatorhub.io</code>.</p>
</blockquote>
<blockquote>
<p>‚ö†Ô∏è Operator Lifecycle Manager (OLM) runs with cluster-admin privileges. ‚Ä¶ Cluster administrators should take measures to ensure that an Operator cannot achieve cluster-scoped privileges.</p>
</blockquote>
<p>Here is the ClusterRole requires by OLM:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Source: original/0000_50_olm_01-olm-operator.serviceaccount.yaml</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> rbac.authorization.k8s.io/v1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> ClusterRole</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> system:controller:operator-lifecycle-manager</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">labels</span><span class="kw">:</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">addonmanager.kubernetes.io/mode</span><span class="kw">:</span><span class="at"> Reconcile</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">rules</span><span class="kw">:</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> </span><span class="fu">apiGroups</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;*&quot;</span><span class="kw">]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">resources</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;*&quot;</span><span class="kw">]</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">verbs</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;*&quot;</span><span class="kw">]</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> </span><span class="fu">nonResourceURLs</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;*&quot;</span><span class="kw">]</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">verbs</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="st">&quot;*&quot;</span><span class="kw">]</span></span></code></pre></div>
<p>Related:</p>
<ul>
<li>Operator Lifecycle Manager<br />
<a href="https://olm.operatorframework.io/" class="uri">https://olm.operatorframework.io/</a></li>
<li><a href="https://docs.openshift.com/container-platform/4.9/operators/admin/olm-creating-policy.html" class="uri">https://docs.openshift.com/container-platform/4.9/operators/admin/olm-creating-policy.html</a></li>
<li><a href="https://github.com/operator-framework/operator-lifecycle-manager/issues/1685" class="uri">https://github.com/operator-framework/operator-lifecycle-manager/issues/1685</a></li>
</ul>
<h2 id="identify-and-remediate-rather-than-gatekeep">Identify and Remediate Rather Than Gatekeep</h2>
<p>Recently, I abandoned a mini-project and proposal for a <code>validate</code> Helm plugin that used OPA Gatekeeper to pro-actively check a chart to see that its configuration passed policies. Then I realized this would need to be maintained in addition to the OPA Gatekeeper configuration itself. I realized this is redundant and unnecessary but also not even optimal. In fact, other more experienced community members questioned my gate-keeping approach suggest an alternative focus on regularly and automatically auditing what is currently in the cluster.</p>
<p>It‚Äôs rather easy to get something past the gates and into your cluster. It is more important to focus on identifying problems and risks in your active cluster dynamically. This is what the Falco project aims to do. I like the emphasis on adaptability which allows dynamic auditing to adjust parameters much like machine learning security scanning software in other realms of the industry. Eventually, we‚Äôll have bots patrolling our Kubernetes clusters just like they do everything else. This is really where I want to focus our attention rather than on dated gate-keeping approaches.</p>
<p>Related:</p>
<ul>
<li><a href="https://falco.org" class="uri">https://falco.org</a></li>
</ul>
<h2 id="examples">Examples</h2>
<ul>
<li>Node Feature Discovery <a href="https://github.com/rwxrob/k8sapp-nfd" class="uri">https://github.com/rwxrob/k8sapp-nfd</a></li>
<li>JupyterHub <a href="https://github.com/rwxrob/k8sapp-jhub" class="uri">https://github.com/rwxrob/k8sapp-jhub</a></li>
</ul>
</body>
</html>
